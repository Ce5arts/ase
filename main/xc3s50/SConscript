import os

# import everything exported in SConstruct

Import('*')

PROJECT = "main"

# various files generated by the Xilinx tools

srcfiles=[ 
  "sram_addr_adder.vhd",
  "nextx_adder.vhd",
  "sprite_memory.vhd",
  "command_fifo.vhd",
  "constants.vhdl",
  "functions.vhdl",
  "sprite_writer.vhdl",
  "reset_conditioner.vhdl",
  "mcu_interface.vhdl",
  "lcd_sender.vhdl",
  "lcd_arbiter.vhdl",
  "frame_writer.vhdl",
  "frame_counter.vhdl",
  "clock_generator.vhdl",
  "main.vhdl"
]

utfile=PROJECT+".ut"
xstfile=PROJECT+".xst"
ngcfile=PROJECT+".ngc"
ngdfile=PROJECT+".ngd"
ucffile=PROJECT+".ucf"
pcffile=PROJECT+".pcf"
mapncdfile=PROJECT+"_map.ncd"
ncdfile=PROJECT+".ncd"
twrfile=PROJECT+".twr"
bitfile=PROJECT+".bit"


#
# Step 1: generate cores and run xst
#

if fpga in ["synthesize","translate","map","par","bitgen"]:

  # another Xilinx exercise in pure stupidity - coregen actually modifies the _source_ .xco during the build
  # completely breaking our ability to have the output depend on a change to the source. I've created a dummy
  # file "regen_cores.txt" that should have its content randomly changed if the cores should be rebuilt

  env.Command("sram_addr_adder.vhd","regen_cores.txt","coregen -b sram_addr_adder.xco -p coregen.cgp",chdir=1)
  env.Command("nextx_adder.vhd","regen_cores.txt","coregen -b nextx_adder.xco -p coregen.cgp",chdir=1)
  env.Command("sprite_memory.vhd","regen_cores.txt","coregen -b sprite_memory.xco -p coregen.cgp",chdir=1)
  env.Command("command_fifo.vhd","regen_cores.txt","coregen -b command_fifo.xco -p coregen.cgp",chdir=1)
  env.Command("regen_cores.txt","","touch regen_cores.txt",chdir=1)

  env.Command("clock_generator.vhdl","clock_generator.xaw","xaw2vhdl -intstyle ise clock_generator.xaw -st XST clock_generator.vhdl",chdir=1)

  ngc=env.Command(
    ngcfile,
    srcfiles,
    [
      Mkdir("tmp/xst/projnav.tmp"),
      "xst -intstyle ise -ifn "+xstfile+" -ofn tmp/"+PROJECT+"_xst.log"
    ],
    chdir=1
  )

#
# Step 2: run ngdbuild to get the NGD file
#


if fpga in ["translate","map","par","bitgen"]:
  ngd=env.Command(
    ngdfile,
    ngcfile,
    [
      "ngdbuild -intstyle ise -dd _ngo -nt timestamp -uc "+ucffile+" -p xc3s50-vq100-5 "+ngcfile+" "+ngdfile
    ],
    chdir=1
  )

#
# Step 3: run map  to get the first NCD file
#

if fpga in ["map","par","bitgen"]:
  mapncd=env.Command(
    mapncdfile,
    ngdfile,
    [
      "map -intstyle ise -p xc3s50-vq100-5 -timing -logic_opt on -ol high -xe c -t 1 -register_duplication on -cm speed -detail -ir off -ignore_keep_hierarchy -pr off -bp -power off -o "+mapncdfile+" "+ngdfile+" "+pcffile
    ],
    chdir=1
  )

#
# Step 4: run par to get the NCD file
#

if fpga in ["par","bitgen"]:
  ncd=env.Command(
    ncdfile,
    mapncdfile,
    [
      "par -w -intstyle ise -ol high -t 1 "+mapncdfile+" "+ncdfile+" "+pcffile
    ],
    chdir=1
  )

  #
  # Step 5: run trce to get the post par static timing report
  #

  twr=env.Command(
    twrfile,
    ncdfile,
    [
      "trce -intstyle ise -v 3 -s 5 -n 3 -fastpaths -xml "+PROJECT+".twx "+ncdfile+" -o "+twrfile+" "+pcffile
    ],
    chdir=1
  )

#
# Step 6: run bitgen to get the output file
#

if fpga == "bitgen":
  bit=env.Command(
    bitfile,
    ncdfile,
    [
      "bitgen -intstyle ise -f "+utfile+" "+ncdfile
    ],
    chdir=1
  )


# 
# Add the numerous temporary files to be cleaned when -c is run
#

env.Clean(
    "clean",
    files=[
      "tmp",
      "isim",
      "xst",
      "_xmsgs",
      "_ngo",
      "fuse.xmsgs",
      "fuseRelaunch.cmd",
      PROJECT+".lso",
      PROJECT+".ngd",
      PROJECT+"_map.ngm",
      PROJECT+".ngr",
      PROJECT+".pad",
      PROJECT+".par",
      PROJECT+".twr",
      PROJECT+".xpi",
      PROJECT+".bgn",
      PROJECT+".drc",
      PROJECT+".ptwx",
      PROJECT+".twx",
      PROJECT+".unroutes",
      PROJECT+"_map.ncd",
      PROJECT+".ncd",
      PROJECT+"_bitgen.xwbt",
      PROJECT+".bld",
      PROJECT+"_map.mrp",
      PROJECT+"_map.map",
      PROJECT+"_pad.csv",
      PROJECT+".pcf",
      PROJECT+"_vhdl.prj",
      "xlnx_auto_0_xdb",
      "usage_statistics_webtalk.html",
      "clock_generator.vhdl",
      "clock_generator_arwz.ucf",
      Glob("*.ngc"),
      Glob("*.asy"),
      Glob("*.gise"),
      Glob("*.log"),
      Glob("*.tcl"),
      Glob("*.cgc"),
      Glob("*.txt"),
      Glob("*.xml"),
      Glob("*.vho"),
      Glob("*.xrpt"),
      Glob("*.xise"),
      Glob("*.psr"),
      "command_fifo",
      "sram_addr_adder",
      "sprite_memory",
      "nextx_adder"
    ])

Return("bit")
